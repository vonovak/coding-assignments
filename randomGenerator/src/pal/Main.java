package pal;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static int A, C, M, N;
    public static byte K;
    public static int[] generatedPrimes;
    public static byte[] nrDistinctPrimes;

    public static void main(String args[]) throws IOException {
        loadInput();

        generatedPrimes = new int[M];
        Arrays.fill(generatedPrimes, 1);
        nrDistinctPrimes = new byte[M];

        /*
        * It is guaranteed the generator has period of length M. For each of the numbers we need to know how many
        * distinct primes are in its decomposition.
        * This is a modified Sieve of Eratosthenes - rather than decomposing the numbers which takes a long time,
        * we will construct numbers that are product of distinct primes and save them to generatedPrimes.
        * The number of distinct primes that was used to generate a number will be stored in nrDistinctPrimes.
        * */
        int j;
        for (int i = 2; i < M / K; i++) {
            if (generatedPrimes[i] == 1) {
                for (j = i; j < M; j += i) {
                    generatedPrimes[j] *= i;
                    nrDistinctPrimes[j]++;
                }
            }
        }

        /*
         * Let us denote integer whose prime factorization consists of K distinct primes by letter I.
         * run through the sequence with a fixed window of size N and find the best subsequence,
         * i.e. the sequence that contains the highest number of Is */
        findBestSubsequence();
    }

    public static void findBestSubsequence() {
        int maxPrimes = 0;
        int bestSeed = 0;
        int tail = 0;

        /*
        * Note the number of Is in the first N elements
        * */
        for (int i = 0; i < N; i++) {
            if (nrDistinctPrimes[tail] == K && generatedPrimes[tail] == tail) {
                maxPrimes++;
            }
            tail = Math.floorMod(A * tail + C, M);
        }

        /*
        * continue through the rest of the sequence by taking in the next element (nrDistinctPrimes[tail]) and noting if it is I (currMaxPrimes++).
        * if the element we're leaving (nrDistinctPrimes[leavingBehind]) is an I, call currMaxPrimes--
        * */

        int leavingBehind = 0;
        int seed = Math.floorMod(C, M);

        int currMaxPrimes = maxPrimes;

        for (int start = 1; start < M; start++) {
            if (nrDistinctPrimes[leavingBehind] == K && generatedPrimes[leavingBehind] == leavingBehind) {
                currMaxPrimes--;
            }
            if (nrDistinctPrimes[tail] == K && generatedPrimes[tail] == tail) {
                currMaxPrimes++;
            }
            if (currMaxPrimes > maxPrimes) {
                maxPrimes = currMaxPrimes;
                bestSeed = seed;
            }
            leavingBehind = seed; //leavingBehind is previous seed
            seed = Math.floorMod(A * seed + C, M); //new seed
            tail = Math.floorMod(A * tail + C, M); //last element of sequence generated by seed
        }

        System.out.println(bestSeed + " " + maxPrimes);
    }

    /*
    * just read the params of the input problem
    * */
    private static void loadInput() throws IOException {
        BufferedReader br;
        StringTokenizer st;
        br = new BufferedReader(new InputStreamReader(System.in));
        st = new StringTokenizer(br.readLine());
        A = Integer.parseInt(st.nextToken());
        C = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        K = Byte.parseByte(st.nextToken());
        N = Integer.parseInt(st.nextToken());
    }
}